#!/usr/bin/env python3
# Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.

from gen_util import outL, types, fmt, product, all_v_comps, jc


def main() -> None:

  outL('''\
// Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.
// This file is generated by gen/mat.py.

import simd
import simd.matrix
import QuiltArithmetic\
''')

  for d in [2, 3, 4]:
    for t in types:
      if not t.simd: continue
      gen_mat(d, t)


def gen_mat(dim, t):
  def isLast(i): return i == dim - 1
  def commaUnlessIsLast(i): return '' if isLast(i) else ','

  vt = fmt('V$$', dim, t.suffix)
  v3t = fmt('V3$', t.suffix)
  mt = fmt('M$$', dim, t.suffix)
  dim_indices = range(dim)
  dim_indices_sqr = tuple(product(dim_indices, dim_indices))

  v_comps = all_v_comps[:dim]
  v_comps_a = tuple('a.' + c for c in v_comps)
  v_comps_b = tuple('b.' + c for c in v_comps)
  v_comps_ab = tuple(zip(v_comps_a, v_comps_b))

  els = tuple(fmt('self[$, $]', i, j) for i, j in dim_indices_sqr)
  els_l = tuple('l.' + c for c in els)
  els_r = tuple('r.' + c for c in els)
  els_lr = tuple(zip(els_l, els_r))

  if   t.scalar == 'F32': simd = 'float'
  elif t.scalar == 'F64': simd = 'double'
  else: raise NotImplementedError

  outL()
  outL()
  outL('public typealias $ = $$x$', mt, simd, dim, dim)
  outL()

  outL('extension $ {', mt)

  for i in dim_indices:
    outL('  public var c$: $ { self[$] }', i, vt, i)
  for j in dim_indices:
    outL('  public var r$: $ { $($) }', j, vt, vt, jc(fmt('self[$, $]', i, j) for i in dim_indices))

  outL('  public static let zero = $(0)', mt)
  outL('  public static let ident = $(1)', mt)

  scale_pars = jc(fmt('$: $', c, t.scalar) for c in v_comps)
  scale_args = jc(c for c in v_comps)
  outL('  public static func scale($) -> $ { $(diagonal: $($)) }\n', scale_pars, mt, mt, vt, scale_args)

  if dim >= 3:
    for k, ck in enumerate(v_comps[:3]): # k is index of rotation axis.
      outL('  public static func rot$(_ theta: $) -> $ { $([', ck.upper(), t.scalar, mt, mt)
      for j, cj in enumerate(v_comps):
        def rot_comp(i, ci):
          if i == k or j == k or i == 3 or j == 3:
            return '1' if i == j else '0'
          if i == j:
            return 'cos(theta)'
          # pick the sign of the sin term by hand, based on row j.
          # i would love to find a more conceptually meaningful way of choosing the sign.
          if k == 0:   isNegSinTerm = (j == 2)
          elif k == 1: isNegSinTerm = (j == 0)
          elif k == 2: isNegSinTerm = (j == 1)
          else: assert False
          return fmt('$sin(theta)', '-' if isNegSinTerm else '')
        outL('    $($)$',
          vt,
          jc(rot_comp(i, ci).rjust(11) for i, ci in enumerate(v_comps)),
          ',' if j < dim - 1 else '')
      outL('  ])}\n')

    outL('  public static func rot(theta: $, norm: $) -> $ {', t.scalar, v3t, mt)
    outL('    if !theta.isNormal { return ident }')
    outL('    let _cos = cos(theta)')
    outL('    let _cosp = 1 - _cos')
    outL('    let _sin = sin(theta)')
    outL('    return $([', mt)

    rot_terms = [
      [ '_cos + _cosp * norm.x * norm.x',
        '_cosp * norm.x * norm.y + norm.z * _sin',
        '_cosp * norm.x * norm.z - norm.y * _sin',
        '0'],

      [ '_cosp * norm.x * norm.y - norm.z * _sin',
        '_cos + _cosp * norm.y * norm.y',
        '_cosp * norm.y * norm.z + norm.x * _sin',
        '0'],

      [ '_cosp * norm.x * norm.z + norm.y * _sin',
        '_cosp * norm.y * norm.z - norm.x * _sin',
        '_cos + _cosp * norm.z * norm.z',
        '0'],

      ['0', '0', '0', '1']
    ]

    for i in dim_indices:
      outL('      $($)$', vt, jc(rot_terms[i][j] for j in dim_indices), commaUnlessIsLast(i))
    outL('  ])}\n')

    outL('  public static func rot(a: $, _ b: $) -> $ {', v3t, v3t, mt)
    outL('    return rot(theta: $(a.angle(b)), norm: a.cross(b).norm)', t.scalar)
    outL('  }')

  outL('}')


if __name__ == '__main__': main()
