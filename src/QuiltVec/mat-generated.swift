// Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.
// This file is generated by gen/mat.py.

import simd
import simd.matrix
import QuiltArithmetic


public typealias M2F = float2x2

extension M2F {
  public var c0: V2F { self[0] }
  public var c1: V2F { self[1] }
  public var r0: V2F { V2F(self[0, 0], self[1, 0]) }
  public var r1: V2F { V2F(self[0, 1], self[1, 1]) }
  public static let zero = M2F(0)
  public static let ident = M2F(1)
  public static func scale(x: F32, y: F32) -> M2F { M2F(diagonal: V2F(x, y)) }

}

public typealias M2D = double2x2

extension M2D {
  public var c0: V2D { self[0] }
  public var c1: V2D { self[1] }
  public var r0: V2D { V2D(self[0, 0], self[1, 0]) }
  public var r1: V2D { V2D(self[0, 1], self[1, 1]) }
  public static let zero = M2D(0)
  public static let ident = M2D(1)
  public static func scale(x: F64, y: F64) -> M2D { M2D(diagonal: V2D(x, y)) }

}

public typealias M3F = float3x3

extension M3F {
  public var c0: V3F { self[0] }
  public var c1: V3F { self[1] }
  public var c2: V3F { self[2] }
  public var r0: V3F { V3F(self[0, 0], self[1, 0], self[2, 0]) }
  public var r1: V3F { V3F(self[0, 1], self[1, 1], self[2, 1]) }
  public var r2: V3F { V3F(self[0, 2], self[1, 2], self[2, 2]) }
  public static let zero = M3F(0)
  public static let ident = M3F(1)
  public static func scale(x: F32, y: F32, z: F32) -> M3F { M3F(diagonal: V3F(x, y, z)) }

  public static func rotX(_ theta: F32) -> M3F { M3F([
    V3F(          1,           0,           0),
    V3F(          0,  cos(theta),  sin(theta)),
    V3F(          0, -sin(theta),  cos(theta))
  ])}

  public static func rotY(_ theta: F32) -> M3F { M3F([
    V3F( cos(theta),           0, -sin(theta)),
    V3F(          0,           1,           0),
    V3F( sin(theta),           0,  cos(theta))
  ])}

  public static func rotZ(_ theta: F32) -> M3F { M3F([
    V3F( cos(theta),  sin(theta),           0),
    V3F(-sin(theta),  cos(theta),           0),
    V3F(          0,           0,           1)
  ])}

  public static func rot(theta: F32, norm: V3F) -> M3F {
    if !theta.isNormal { return ident }
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M3F([
      V3F(_cos + _cosp * norm.x * norm.x, _cosp * norm.x * norm.y + norm.z * _sin, _cosp * norm.x * norm.z - norm.y * _sin),
      V3F(_cosp * norm.x * norm.y - norm.z * _sin, _cos + _cosp * norm.y * norm.y, _cosp * norm.y * norm.z + norm.x * _sin),
      V3F(_cosp * norm.x * norm.z + norm.y * _sin, _cosp * norm.y * norm.z - norm.x * _sin, _cos + _cosp * norm.z * norm.z)
  ])}

  public static func rot(a: V3F, _ b: V3F) -> M3F {
    return rot(theta: F32(a.angle(b)), norm: a.cross(b).norm)
  }

}

public typealias M3D = double3x3

extension M3D {
  public var c0: V3D { self[0] }
  public var c1: V3D { self[1] }
  public var c2: V3D { self[2] }
  public var r0: V3D { V3D(self[0, 0], self[1, 0], self[2, 0]) }
  public var r1: V3D { V3D(self[0, 1], self[1, 1], self[2, 1]) }
  public var r2: V3D { V3D(self[0, 2], self[1, 2], self[2, 2]) }
  public static let zero = M3D(0)
  public static let ident = M3D(1)
  public static func scale(x: F64, y: F64, z: F64) -> M3D { M3D(diagonal: V3D(x, y, z)) }

  public static func rotX(_ theta: F64) -> M3D { M3D([
    V3D(          1,           0,           0),
    V3D(          0,  cos(theta),  sin(theta)),
    V3D(          0, -sin(theta),  cos(theta))
  ])}

  public static func rotY(_ theta: F64) -> M3D { M3D([
    V3D( cos(theta),           0, -sin(theta)),
    V3D(          0,           1,           0),
    V3D( sin(theta),           0,  cos(theta))
  ])}

  public static func rotZ(_ theta: F64) -> M3D { M3D([
    V3D( cos(theta),  sin(theta),           0),
    V3D(-sin(theta),  cos(theta),           0),
    V3D(          0,           0,           1)
  ])}

  public static func rot(theta: F64, norm: V3D) -> M3D {
    if !theta.isNormal { return ident }
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M3D([
      V3D(_cos + _cosp * norm.x * norm.x, _cosp * norm.x * norm.y + norm.z * _sin, _cosp * norm.x * norm.z - norm.y * _sin),
      V3D(_cosp * norm.x * norm.y - norm.z * _sin, _cos + _cosp * norm.y * norm.y, _cosp * norm.y * norm.z + norm.x * _sin),
      V3D(_cosp * norm.x * norm.z + norm.y * _sin, _cosp * norm.y * norm.z - norm.x * _sin, _cos + _cosp * norm.z * norm.z)
  ])}

  public static func rot(a: V3D, _ b: V3D) -> M3D {
    return rot(theta: F64(a.angle(b)), norm: a.cross(b).norm)
  }

}

public typealias M4F = float4x4

extension M4F {
  public var c0: V4F { self[0] }
  public var c1: V4F { self[1] }
  public var c2: V4F { self[2] }
  public var c3: V4F { self[3] }
  public var r0: V4F { V4F(self[0, 0], self[1, 0], self[2, 0], self[3, 0]) }
  public var r1: V4F { V4F(self[0, 1], self[1, 1], self[2, 1], self[3, 1]) }
  public var r2: V4F { V4F(self[0, 2], self[1, 2], self[2, 2], self[3, 2]) }
  public var r3: V4F { V4F(self[0, 3], self[1, 3], self[2, 3], self[3, 3]) }
  public static let zero = M4F(0)
  public static let ident = M4F(1)
  public static func scale(x: F32, y: F32, z: F32, w: F32) -> M4F { M4F(diagonal: V4F(x, y, z, w)) }

  public static func rotX(_ theta: F32) -> M4F { M4F([
    V4F(          1,           0,           0,           0),
    V4F(          0,  cos(theta),  sin(theta),           0),
    V4F(          0, -sin(theta),  cos(theta),           0),
    V4F(          0,           0,           0,           1)
  ])}

  public static func rotY(_ theta: F32) -> M4F { M4F([
    V4F( cos(theta),           0, -sin(theta),           0),
    V4F(          0,           1,           0,           0),
    V4F( sin(theta),           0,  cos(theta),           0),
    V4F(          0,           0,           0,           1)
  ])}

  public static func rotZ(_ theta: F32) -> M4F { M4F([
    V4F( cos(theta),  sin(theta),           0,           0),
    V4F(-sin(theta),  cos(theta),           0,           0),
    V4F(          0,           0,           1,           0),
    V4F(          0,           0,           0,           1)
  ])}

  public static func rot(theta: F32, norm: V3F) -> M4F {
    if !theta.isNormal { return ident }
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M4F([
      V4F(_cos + _cosp * norm.x * norm.x, _cosp * norm.x * norm.y + norm.z * _sin, _cosp * norm.x * norm.z - norm.y * _sin, 0),
      V4F(_cosp * norm.x * norm.y - norm.z * _sin, _cos + _cosp * norm.y * norm.y, _cosp * norm.y * norm.z + norm.x * _sin, 0),
      V4F(_cosp * norm.x * norm.z + norm.y * _sin, _cosp * norm.y * norm.z - norm.x * _sin, _cos + _cosp * norm.z * norm.z, 0),
      V4F(0, 0, 0, 1)
  ])}

  public static func rot(a: V3F, _ b: V3F) -> M4F {
    return rot(theta: F32(a.angle(b)), norm: a.cross(b).norm)
  }

}

public typealias M4D = double4x4

extension M4D {
  public var c0: V4D { self[0] }
  public var c1: V4D { self[1] }
  public var c2: V4D { self[2] }
  public var c3: V4D { self[3] }
  public var r0: V4D { V4D(self[0, 0], self[1, 0], self[2, 0], self[3, 0]) }
  public var r1: V4D { V4D(self[0, 1], self[1, 1], self[2, 1], self[3, 1]) }
  public var r2: V4D { V4D(self[0, 2], self[1, 2], self[2, 2], self[3, 2]) }
  public var r3: V4D { V4D(self[0, 3], self[1, 3], self[2, 3], self[3, 3]) }
  public static let zero = M4D(0)
  public static let ident = M4D(1)
  public static func scale(x: F64, y: F64, z: F64, w: F64) -> M4D { M4D(diagonal: V4D(x, y, z, w)) }

  public static func rotX(_ theta: F64) -> M4D { M4D([
    V4D(          1,           0,           0,           0),
    V4D(          0,  cos(theta),  sin(theta),           0),
    V4D(          0, -sin(theta),  cos(theta),           0),
    V4D(          0,           0,           0,           1)
  ])}

  public static func rotY(_ theta: F64) -> M4D { M4D([
    V4D( cos(theta),           0, -sin(theta),           0),
    V4D(          0,           1,           0,           0),
    V4D( sin(theta),           0,  cos(theta),           0),
    V4D(          0,           0,           0,           1)
  ])}

  public static func rotZ(_ theta: F64) -> M4D { M4D([
    V4D( cos(theta),  sin(theta),           0,           0),
    V4D(-sin(theta),  cos(theta),           0,           0),
    V4D(          0,           0,           1,           0),
    V4D(          0,           0,           0,           1)
  ])}

  public static func rot(theta: F64, norm: V3D) -> M4D {
    if !theta.isNormal { return ident }
    let _cos = cos(theta)
    let _cosp = 1 - _cos
    let _sin = sin(theta)
    return M4D([
      V4D(_cos + _cosp * norm.x * norm.x, _cosp * norm.x * norm.y + norm.z * _sin, _cosp * norm.x * norm.z - norm.y * _sin, 0),
      V4D(_cosp * norm.x * norm.y - norm.z * _sin, _cos + _cosp * norm.y * norm.y, _cosp * norm.y * norm.z + norm.x * _sin, 0),
      V4D(_cosp * norm.x * norm.z + norm.y * _sin, _cosp * norm.y * norm.z - norm.x * _sin, _cos + _cosp * norm.z * norm.z, 0),
      V4D(0, 0, 0, 1)
  ])}

  public static func rot(a: V3D, _ b: V3D) -> M4D {
    return rot(theta: F64(a.angle(b)), norm: a.cross(b).norm)
  }

}
