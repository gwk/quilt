// Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.
// This file is generated by gen/vec.py.

import Darwin
import simd
import QuiltArithmetic


extension SIMD3: Vec, Vec3 where Scalar: ArithmeticProtocol { // Float/Int agnostic.
  public typealias VFType = V3F
  public typealias VDType = V3D
  public typealias VU8Type = V3U8
  public typealias V2Type = SIMD2<Scalar>

  public init(_ v: V3F) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3D) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3I) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3I8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3I16) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3I32) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3U8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3U16) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V3U32) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4F) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4D) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4I) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4I8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4I16) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4I32) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4U8) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4U16) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: V4U32) {
    self.init(Scalar(v.x), Scalar(v.y), Scalar(v.z))
  }
  public init(_ v: SIMD2<Scalar>, z: Scalar) {
    self.init(v.x, v.y, z)
  }

  public static var scalarCount: Int { 3 }
  public static var zero: Self { Self.init() }
  public static var one: Self { Self.init(1, 1, 1) }

  public func dot(_ b: SIMD3<Scalar>) -> F64 {
    var s = x.asF64 * b.x.asF64
    s += y.asF64 * b.y.asF64
    s += z.asF64 * b.z.asF64
    return s
  }

}


extension SIMD3: FloatVec, FloatVec3 where Scalar: ArithmeticFloat { // Float-specific.

  public var allFinite: Bool { x.isFinite && (y.isFinite && (z.isFinite)) }
  public var allZero: Bool { x.isZero && (y.isZero && (z.isZero)) }
  public var allZeroOrSubnormal: Bool { x.isZeroOrSubnormal && (y.isZeroOrSubnormal && (z.isZeroOrSubnormal)) }
  public var anySubnormal: Bool { x.isSubnormal || (y.isSubnormal || (z.isSubnormal))}
  public var anyInfite: Bool { x.isInfinite || (y.isInfinite || (z.isInfinite))}
  public var anyNaN: Bool { x.isNaN || (y.isNaN || (z.isNaN))}
  public var anyZero: Bool { x.isZero && (y.isZero && (z.isZero)) }
  public var anyZeroOrSubnormal: Bool { x.isZeroOrSubnormal || (y.isZeroOrSubnormal || (z.isZeroOrSubnormal)) }
  public var clampToUnit: SIMD3 { SIMD3(x.clamp(min: 0, max: 1), y.clamp(min: 0, max: 1), z.clamp(min: 0, max: 1)) }
  public var clampToSignedUnit: SIMD3 { SIMD3(x.clamp(min: -1, max: 1), y.clamp(min: -1, max: 1), z.clamp(min: -1, max: 1)) }
  public var toU8Pixel: VU8Type { VU8Type(U8((x*255).clamp(min: 0, max: 255)), U8((y*255).clamp(min: 0, max: 255)), U8((z*255).clamp(min: 0, max: 255))) }
}


extension SIMD3: Comparable where Scalar: Comparable{
  public static func <(a: SIMD3, b: SIMD3) -> Bool {
    if a.x != b.x { return a.x < b.x }
    if a.y != b.y { return a.y < b.y }
    return a.z < b.z
  }
}
