// Dedicated to the public domain under CC0: https://creativecommons.org/publicdomain/zero/1.0/.
// This file is generated by gen/vec.py.

import Darwin
import simd
import QuiltArithmetic
import CoreGraphics
import QuiltVec


public typealias V2 = CGPoint
extension V2: Vec, Vec2 { // Float/Int agnostic.
  public typealias Scalar = CGFloat
  public typealias VFType = V2F
  public typealias VDType = V2D
  public typealias VU8Type = V2U8
  public typealias V2Type = V2

  public init(_ v: V2F) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2D) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2I) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2I8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2I16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2I32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2U8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2U16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V2U32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3F) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3D) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3I) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3I8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3I16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3I32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3U8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3U16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V3U32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4F) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4D) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4I) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4I8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4I16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4I32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4U8) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4U16) {
    self.init(Scalar(v.x), Scalar(v.y))
  }
  public init(_ v: V4U32) {
    self.init(Scalar(v.x), Scalar(v.y))
  }

  public subscript(index: Int) -> Scalar {
    get {
      switch index {
      case 0: return x
      case 1: return y
      default: fatalError("subscript out of range: \(index)")
      }
    }
    set {
      switch index {
      case 0: x = newValue
      case 1: y = newValue
      default: fatalError("subscript out of range: \(index)")
      }
    }
  }

  public static var scalarCount: Int { 2 }
  public static var one: Self { Self.init(1, 1) }

  public func dot(_ b: V2) -> F64 {
    var s = x.asF64 * b.x.asF64
    s += y.asF64 * b.y.asF64
    return s
  }

public static func +(a: V2, b: V2) -> V2 { V2(a.x + b.x, a.y + b.y) }
public static func -(a: V2, b: V2) -> V2 { V2(a.x - b.x, a.y - b.y) }
public static func *(a: V2, b: V2) -> V2 { V2(a.x * b.x, a.y * b.y) }
public static func /(a: V2, b: V2) -> V2 { V2(a.x / b.x, a.y / b.y) }
public static func +(a: V2, s: CGFloat) -> V2 { V2(a.x + s, a.y + s) }
public static func -(a: V2, s: CGFloat) -> V2 { V2(a.x - s, a.y - s) }
public static func *(a: V2, s: CGFloat) -> V2 { V2(a.x * s, a.y * s) }
public static func /(a: V2, s: CGFloat) -> V2 { V2(a.x / s, a.y / s) }
public static prefix func -(a: V2) -> V2 { a * -1 }
}


extension V2: FloatVec, FloatVec2 { // Float-specific.

  public var allFinite: Bool { x.isFinite && (y.isFinite) }
  public var allZero: Bool { x.isZero && (y.isZero) }
  public var allZeroOrSubnormal: Bool { x.isZeroOrSubnormal && (y.isZeroOrSubnormal) }
  public var anySubnormal: Bool { x.isSubnormal || (y.isSubnormal)}
  public var anyInfite: Bool { x.isInfinite || (y.isInfinite)}
  public var anyNaN: Bool { x.isNaN || (y.isNaN)}
  public var anyZero: Bool { x.isZero && (y.isZero) }
  public var anyZeroOrSubnormal: Bool { x.isZeroOrSubnormal || (y.isZeroOrSubnormal) }
  public var clampToUnit: V2 { V2(x.clamp(min: 0, max: 1), y.clamp(min: 0, max: 1)) }
  public var clampToSignedUnit: V2 { V2(x.clamp(min: -1, max: 1), y.clamp(min: -1, max: 1)) }
  public var toU8Pixel: VU8Type { VU8Type(U8((x*255).clamp(min: 0, max: 255)), U8((y*255).clamp(min: 0, max: 255))) }
}


extension V2: Comparable {
  public static func <(a: V2, b: V2) -> Bool {
    if a.x != b.x { return a.x < b.x }
    return a.y < b.y
  }
}

extension V2: CustomStringConvertible {
  public var description: String { "V2(\(x), \(y))" }
}
